# QuantCapital 量化交易框架 - 用户入门手册

欢迎使用 QuantCapital 量化交易框架！这是一个专为A股市场设计的事件驱动量化交易系统，支持回测与实盘交易的一致性。

## 🚀 快速开始

### 1. 环境准备

#### 系统要求
- Python 3.8+
- 至少 8GB 内存（用于大量历史数据处理）
- 至少 10GB 磁盘空间（用于存储历史数据）

#### 安装依赖

```bash
# 克隆项目
git clone <your-repo-url>
cd quantcapital

# 安装依赖
pip install -r requirements.txt

# 运行测试确保安装正确
pytest tests/ -v
```

### 2. 初始化配置

创建配置文件 `config/backtest.json`：

```json
{
  "env": "backtest",
  "data_root": "./data",
  "business_db_path": "./data/business.db",
  "initial_capital": 1000000.0,
  "data_source": {
    "request_delay": 0.1
  },
  "execution": {
    "slippage": 0.001,
    "commission_rate": 0.0003,
    "delay_seconds": 1
  },
  "portfolio": {
    "max_position_pct": 0.05,
    "max_total_position_pct": 0.95,
    "min_order_amount": 1000,
    "position_size_method": "fixed_amount",
    "default_position_size": 10000
  },
  "logging": {
    "level": "INFO",
    "file_enabled": true,
    "console_enabled": true
  }
}
```

## 📊 数据获取和管理

### 1. 下载历史数据

创建数据下载脚本 `download_data.py`：

```python
#!/usr/bin/env python3
"""
数据下载脚本

下载A股、ETF、指数的历史数据到本地存储。
"""

import logging
from datetime import datetime, timedelta
from quantcapital.config import ConfigManager
from quantcapital.data import DataUpdater
from quantcapital.engine import EventEngine

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def main():
    """主函数"""
    # 加载配置
    config = ConfigManager()
    config.load_config('config/backtest.json')
    
    # 创建事件引擎
    event_engine = EventEngine()
    event_engine.start()
    
    try:
        # 创建数据更新器
        updater = DataUpdater(config.config, event_engine)
        
        # 设置数据更新日期范围
        end_date = datetime.now()
        start_date = end_date - timedelta(days=365)  # 下载一年数据
        
        logger.info(f"开始下载数据: {start_date.date()} - {end_date.date()}")
        
        # 手动触发数据更新
        updater.update_data()
        
        logger.info("数据下载完成！")
        
    except Exception as e:
        logger.error(f"数据下载失败: {e}")
    finally:
        event_engine.stop()

if __name__ == "__main__":
    main()
```

运行数据下载：

```bash
python download_data.py
```

### 2. 数据存储结构

下载完成后，数据存储结构如下：

```
data/
├── kline/                          # K线数据（Parquet格式）
│   ├── frequency=daily/
│   │   ├── year=2023/
│   │   │   └── data.parquet        # 日线数据
│   │   └── year=2024/
│   │       └── data.parquet
│   ├── frequency=hourly/           # 小时线数据
│   └── frequency=weekly/           # 周线数据
├── business.db                     # 业务数据（SQLite）
└── temp/                          # 临时文件
    └── *.duckdb                   # 回测时的内存数据库
```

### 3. 查看已下载的数据

创建数据查看脚本 `check_data.py`：

```python
#!/usr/bin/env python3
"""
数据查看脚本

检查已下载的数据情况。
"""

import pandas as pd
from quantcapital.config import ConfigManager
from quantcapital.data import BacktestDataHandler

def main():
    config = ConfigManager()
    config.load_config('config/backtest.json')
    
    # 创建数据处理器
    data_handler = BacktestDataHandler(
        data_root=config.get('data_root'),
        business_db_path=config.get('business_db_path')
    )
    
    # 查看股票池
    universe = data_handler.business_storage.load_universe("default")
    print(f"股票池包含 {len(universe)} 支股票:")
    print(universe[:10])  # 显示前10支
    
    # 查看数据统计
    if universe:
        sample_symbol = universe[0]
        bars = data_handler.get_latest_bars([sample_symbol], "DAILY", 10)
        
        if sample_symbol in bars and bars[sample_symbol]:
            print(f"\n{sample_symbol} 最新10个交易日数据:")
            for bar in bars[sample_symbol][-5:]:  # 显示最近5个
                print(f"  {bar.datetime.date()}: 开={bar.open:.2f}, "
                     f"高={bar.high:.2f}, 低={bar.low:.2f}, 收={bar.close:.2f}")

if __name__ == "__main__":
    main()
```

运行数据检查：

```bash
python check_data.py
```

## 📈 编写交易策略

### 1. 创建自定义策略

创建你的第一个策略 `my_strategy.py`：

```python
from datetime import datetime
from typing import List, Set
from quantcapital.strategy import BaseStrategy
from quantcapital.entities import Signal, SignalDirection, Bar, StrategyType

class MyMATrendStrategy(BaseStrategy):
    """我的均线趋势策略"""
    
    def __init__(self, strategy_instance, event_engine, data_handler):
        super().__init__(strategy_instance, event_engine)
        self.data_handler = data_handler
        
        # 策略参数
        self.ma_window = self.config.get('ma_window', 20)      # 均线周期
        self.volume_threshold = self.config.get('volume_threshold', 1.2)  # 成交量阈值
        self.universe = set(self.config.get('universe', []))
        
    def get_watch_symbols(self) -> Set[str]:
        """获取关注标的"""
        if self.strategy_type == StrategyType.ENTRY:
            # 开单策略：关注股票池中未持有的标的
            strategy_positions = self.get_strategy_positions()
            return self.universe - strategy_positions
        elif self.strategy_type == StrategyType.EXIT:
            # 止损策略：关注本策略的持仓
            return self.get_strategy_positions()
        return set()
    
    def generate_signals(self, market_event) -> List[Signal]:
        """生成交易信号"""
        signals = []
        symbol = market_event.symbol
        current_bar = market_event.bar_data
        
        try:
            if self.strategy_type == StrategyType.ENTRY:
                signal = self._check_entry_signal(symbol, current_bar)
                if signal:
                    signals.append(signal)
            elif self.strategy_type == StrategyType.EXIT:
                signal = self._check_exit_signal(symbol, current_bar)
                if signal:
                    signals.append(signal)
        except Exception as e:
            self.logger.debug(f"生成信号失败 {symbol}: {e}")
        
        return signals
    
    def _check_entry_signal(self, symbol: str, current_bar: Bar) -> Signal:
        """检查开单信号"""
        # 获取历史数据
        historical_bars = self._get_historical_data(symbol, self.ma_window + 5)
        
        if len(historical_bars) < self.ma_window:
            return None
        
        # 计算均线
        ma_current = self._calculate_ma(historical_bars, self.ma_window)
        ma_prev = self._calculate_ma(historical_bars[:-1], self.ma_window)
        
        if ma_current is None or ma_prev is None:
            return None
        
        # 策略逻辑：价格上穿均线 + 成交量放大
        price_breakout = (current_bar.close > ma_current and 
                         historical_bars[-2].close <= ma_prev)
        
        # 计算成交量比（当前成交量 vs 平均成交量）
        avg_volume = sum(bar.volume for bar in historical_bars[-10:]) / 10
        volume_surge = current_bar.volume > avg_volume * self.volume_threshold
        
        if price_breakout and volume_surge:
            return Signal(
                strategy_id=self.strategy_id,
                symbol=symbol,
                direction=SignalDirection.BUY,
                strength=0.8,
                timestamp=current_bar.datetime,
                price=current_bar.close,
                reason=f"价格上穿均线+成交量放大: MA={ma_current:.2f}, 量比={current_bar.volume/avg_volume:.2f}"
            )
        
        return None
    
    def _check_exit_signal(self, symbol: str, current_bar: Bar) -> Signal:
        """检查止损信号"""
        if not self.portfolio_manager or not self.portfolio_manager.account:
            return None
        
        position = self.portfolio_manager.account.get_position(symbol)
        if not position or position.is_empty:
            return None
        
        # 止损逻辑：跌破均线
        historical_bars = self._get_historical_data(symbol, self.ma_window + 5)
        if len(historical_bars) < self.ma_window:
            return None
        
        ma_current = self._calculate_ma(historical_bars, self.ma_window)
        if ma_current is None:
            return None
        
        if current_bar.close < ma_current:
            return Signal(
                strategy_id=self.strategy_id,
                symbol=symbol,
                direction=SignalDirection.SELL,
                strength=0.9,
                timestamp=current_bar.datetime,
                price=current_bar.close,
                reason=f"跌破均线止损: 当前价={current_bar.close:.2f}, MA={ma_current:.2f}"
            )
        
        return None
    
    def _get_historical_data(self, symbol: str, count: int) -> List[Bar]:
        """获取历史数据"""
        try:
            from quantcapital.entities import Frequency
            bars_dict = self.data_handler.get_latest_bars([symbol], Frequency.DAILY, count)
            return bars_dict.get(symbol, [])
        except Exception as e:
            return []
    
    def _calculate_ma(self, bars: List[Bar], window: int) -> float:
        """计算移动平均线"""
        if len(bars) < window:
            return None
        
        prices = [bar.close for bar in bars[-window:]]
        return sum(prices) / len(prices)
```

### 2. 策略配置

创建策略配置文件 `strategies/my_trend_config.json`：

```json
{
  "strategy_id": "my_ma_trend_entry",
  "name": "我的均线趋势开单策略",
  "strategy_type": "entry",
  "enabled": true,
  "config": {
    "ma_window": 20,
    "volume_threshold": 1.5,
    "universe": [
      "000001.SZ", "000002.SZ", "000858.SZ", "000725.SZ",
      "600000.SH", "600036.SH", "600519.SH", "600276.SH"
    ]
  }
}
```

## 🔬 运行回测

### 1. 创建回测脚本

创建完整回测脚本 `run_backtest.py`：

```python
#!/usr/bin/env python3
"""
回测运行脚本

使用自定义策略进行历史回测。
"""

import json
import logging
from datetime import datetime, timedelta
from quantcapital.config import ConfigManager
from quantcapital.backtest import BacktestEngine
from quantcapital.entities import StrategyInstance, StrategyType
from my_strategy import MyMATrendStrategy

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def load_strategy_config(config_file: str) -> StrategyInstance:
    """加载策略配置"""
    with open(config_file, 'r', encoding='utf-8') as f:
        config_data = json.load(f)
    
    return StrategyInstance(
        strategy_id=config_data['strategy_id'],
        name=config_data['name'],
        strategy_type=StrategyType(config_data['strategy_type']),
        enabled=config_data['enabled'],
        config=config_data['config']
    )

def main():
    """主函数"""
    # 加载配置
    config = ConfigManager()
    config.load_config('config/backtest.json')
    
    # 创建回测引擎
    backtest_engine = BacktestEngine(config)
    
    # 设置回测参数
    end_date = datetime.now()
    start_date = end_date - timedelta(days=90)  # 回测3个月
    
    # 加载策略配置
    strategy_config = load_strategy_config('strategies/my_trend_config.json')
    universe = strategy_config.config['universe']
    
    logger.info(f"回测设置:")
    logger.info(f"  时间范围: {start_date.date()} - {end_date.date()}")
    logger.info(f"  股票池: {len(universe)} 支股票")
    logger.info(f"  初始资金: {config.get('initial_capital'):,.0f} 元")
    
    # 创建策略实例
    entry_strategy = MyMATrendStrategy(
        strategy_config, 
        backtest_engine.event_engine,
        None  # 数据处理器将在setup时设置
    )
    
    # 创建对应的止损策略
    exit_config = StrategyInstance(
        strategy_id="my_ma_trend_exit",
        name="我的均线趋势止损策略",
        strategy_type=StrategyType.EXIT,
        enabled=True,
        config=strategy_config.config
    )
    
    exit_strategy = MyMATrendStrategy(
        exit_config,
        backtest_engine.event_engine,
        None
    )
    
    # 设置回测参数
    backtest_engine.setup(
        start_date=start_date,
        end_date=end_date,
        universe=universe,
        strategies=[entry_strategy, exit_strategy]
    )
    
    # 为策略设置数据处理器
    entry_strategy.data_handler = backtest_engine.data_handler
    exit_strategy.data_handler = backtest_engine.data_handler
    
    try:
        # 准备数据
        logger.info("准备回测数据...")
        if not backtest_engine.prepare_data():
            logger.error("数据准备失败")
            return
        
        # 运行回测
        logger.info("开始运行回测...")
        if backtest_engine.run():
            # 打印结果
            backtest_engine.print_results()
            
            # 保存详细结果
            results = backtest_engine.get_results()
            with open('backtest_results.json', 'w', encoding='utf-8') as f:
                # 转换datetime为字符串
                results_json = {}
                for key, value in results.items():
                    if isinstance(value, datetime):
                        results_json[key] = value.isoformat()
                    else:
                        results_json[key] = value
                
                json.dump(results_json, f, indent=2, ensure_ascii=False)
            
            logger.info("回测结果已保存到 backtest_results.json")
        else:
            logger.error("回测运行失败")
    
    except KeyboardInterrupt:
        logger.info("用户中断回测")
    except Exception as e:
        logger.error(f"回测执行异常: {e}", exc_info=True)

if __name__ == "__main__":
    main()
```

### 2. 运行回测

```bash
# 确保数据已下载
python download_data.py

# 运行回测
python run_backtest.py
```

### 3. 查看回测结果

回测完成后，你将看到类似以下的输出：

```
============================================================
回测结果摘要
============================================================
回测期间: 2024-01-01 - 2024-03-31
初始资金: 1,000,000.00 元
最终价值: 1,035,240.00 元
总收益率: 3.52%
总交易次数: 15
胜率: 66.67%
总手续费: 89.50 元
已实现盈亏: 35,329.50 元

策略统计:
  总策略数: 2
  活跃策略数: 2

持仓统计:
  持仓数量: 3
  持仓价值: 298,740.00 元
  杠杆率: 0.30
============================================================
```

## 🔧 高级功能

### 1. 策略参数优化

创建参数优化脚本 `optimize_strategy.py`：

```python
#!/usr/bin/env python3
"""
策略参数优化

通过网格搜索找到最优参数组合。
"""

import itertools
from run_backtest import main as run_single_backtest

def optimize_parameters():
    """参数优化"""
    # 定义参数范围
    ma_windows = [10, 15, 20, 25, 30]
    volume_thresholds = [1.2, 1.5, 1.8, 2.0]
    
    best_return = -float('inf')
    best_params = None
    results = []
    
    # 网格搜索
    for ma_window, volume_threshold in itertools.product(ma_windows, volume_thresholds):
        print(f"测试参数: MA窗口={ma_window}, 成交量阈值={volume_threshold}")
        
        # 修改配置文件
        # ... 更新策略配置 ...
        
        # 运行回测
        result = run_single_backtest()
        
        if result and result['total_return'] > best_return:
            best_return = result['total_return']
            best_params = (ma_window, volume_threshold)
        
        results.append({
            'ma_window': ma_window,
            'volume_threshold': volume_threshold,
            'return': result['total_return'] if result else None
        })
    
    print(f"最优参数: MA窗口={best_params[0]}, 成交量阈值={best_params[1]}")
    print(f"最优收益率: {best_return:.2%}")

if __name__ == "__main__":
    optimize_parameters()
```

### 2. 实盘交易准备

创建实盘配置 `config/live_trading.json`：

```json
{
  "env": "live_trading",
  "data_root": "./data",
  "business_db_path": "./data/business.db",
  "initial_capital": 100000.0,
  "execution": {
    "slippage": 0.002,
    "commission_rate": 0.0003,
    "delay_seconds": 2,
    "miniapi_config": {
      "host": "localhost",
      "port": 8888,
      "username": "your_username",
      "password": "your_password"
    }
  },
  "portfolio": {
    "max_position_pct": 0.03,
    "max_total_position_pct": 0.85,
    "min_order_amount": 5000
  },
  "risk": {
    "daily_loss_limit": 0.02,
    "max_drawdown": 0.05
  }
}
```

### 3. 监控和报警

创建监控脚本 `monitor.py`：

```python
#!/usr/bin/env python3
"""
交易监控脚本

监控实盘交易状态和风险指标。
"""

import time
import smtplib
from email.mime.text import MIMEText
from quantcapital.config import ConfigManager
from quantcapital.portfolio import PortfolioRiskManager

def send_alert(subject: str, message: str):
    """发送邮件告警"""
    # 配置邮件服务器
    # ... 发送邮件逻辑 ...
    pass

def monitor_trading():
    """监控交易状态"""
    while True:
        try:
            # 检查账户状态
            # ... 监控逻辑 ...
            
            # 检查风险指标
            # ... 风险检查 ...
            
            time.sleep(60)  # 每分钟检查一次
            
        except Exception as e:
            send_alert("交易监控异常", f"监控程序异常: {e}")
            time.sleep(300)  # 异常时等待5分钟

if __name__ == "__main__":
    monitor_trading()
```

## 📚 进阶学习

### 1. 了解框架架构

- **事件驱动**: 所有组件通过事件通信，解耦合设计
- **分层存储**: Parquet(归档) + DuckDB(查询) + SQLite(业务)
- **策略分离**: 开单、止损、风控策略独立运行
- **回测一致性**: 相同代码可用于回测和实盘

### 2. 扩展框架功能

```python
# 自定义技术指标
from quantcapital.data.indicators import TechnicalIndicators

class MyIndicators(TechnicalIndicators):
    def calculate_custom_indicator(self, bars):
        # 实现自定义指标
        pass

# 自定义数据源
from quantcapital.data.data_source import DataSource

class MyDataSource(DataSource):
    def get_kline_data(self, symbols, frequency, start_date, end_date):
        # 实现自定义数据获取
        pass
```

### 3. 性能优化

- **数据预加载**: 回测前将数据加载到内存
- **并行计算**: 多进程处理大量标的
- **缓存机制**: 缓存技术指标计算结果
- **增量更新**: 只更新最新的数据

## ❓ 常见问题

### Q: 如何添加新的股票到股票池？

```python
from quantcapital.data import BacktestDataHandler

data_handler = BacktestDataHandler(data_root="./data", business_db_path="./data/business.db")
current_universe = data_handler.business_storage.load_universe("default")
new_universe = current_universe + ["600519.SH", "000858.SZ"]
data_handler.business_storage.save_universe("default", new_universe)
```

### Q: 如何调试策略信号？

```python
# 在策略中添加详细日志
import logging
logger = logging.getLogger(__name__)

def generate_signals(self, market_event):
    logger.debug(f"处理 {market_event.symbol} 行情: 收盘价={market_event.bar_data.close:.2f}")
    # ... 策略逻辑 ...
```

### Q: 如何处理停牌股票？

框架会自动跳过无数据的交易日，停牌股票不会触发交易信号。

### Q: 如何设置不同的手续费率？

在配置文件中修改 `execution.commission_rate`，支持买卖不同费率。

## 📞 获取支持

- **文档**: 查看项目 README 和代码注释
- **测试**: 运行 `pytest tests/` 验证功能
- **社区**: 提交 Issue 或 Pull Request

---

**祝您使用愉快！开始您的量化交易之旅吧！** 🎉