# QuantCapital é‡åŒ–äº¤æ˜“æ¡†æ¶ - ç”¨æˆ·å…¥é—¨æ‰‹å†Œ

æ¬¢è¿ä½¿ç”¨ QuantCapital é‡åŒ–äº¤æ˜“æ¡†æ¶ï¼è¿™æ˜¯ä¸€ä¸ªä¸“ä¸ºAè‚¡å¸‚åœºè®¾è®¡çš„äº‹ä»¶é©±åŠ¨é‡åŒ–äº¤æ˜“ç³»ç»Ÿï¼Œæ”¯æŒå›æµ‹ä¸å®ç›˜äº¤æ˜“çš„ä¸€è‡´æ€§ã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. ç¯å¢ƒå‡†å¤‡

#### ç³»ç»Ÿè¦æ±‚
- Python 3.8+
- è‡³å°‘ 8GB å†…å­˜ï¼ˆç”¨äºå¤§é‡å†å²æ•°æ®å¤„ç†ï¼‰
- è‡³å°‘ 10GB ç£ç›˜ç©ºé—´ï¼ˆç”¨äºå­˜å‚¨å†å²æ•°æ®ï¼‰

#### å®‰è£…ä¾èµ–

```bash
# å…‹éš†é¡¹ç›®
git clone <your-repo-url>
cd quantcapital

# å®‰è£…ä¾èµ–
pip install -r requirements.txt

# è¿è¡Œæµ‹è¯•ç¡®ä¿å®‰è£…æ­£ç¡®
pytest tests/ -v
```

### 2. åˆå§‹åŒ–é…ç½®

åˆ›å»ºé…ç½®æ–‡ä»¶ `config/backtest.json`ï¼š

```json
{
  "env": "backtest",
  "data_root": "./data",
  "business_db_path": "./data/business.db",
  "initial_capital": 1000000.0,
  "data_source": {
    "request_delay": 0.1
  },
  "execution": {
    "slippage": 0.001,
    "commission_rate": 0.0003,
    "delay_seconds": 1
  },
  "portfolio": {
    "max_position_pct": 0.05,
    "max_total_position_pct": 0.95,
    "min_order_amount": 1000,
    "position_size_method": "fixed_amount",
    "default_position_size": 10000
  },
  "logging": {
    "level": "INFO",
    "file_enabled": true,
    "console_enabled": true
  }
}
```

## ğŸ“Š æ•°æ®è·å–å’Œç®¡ç†

### 1. ä¸‹è½½å†å²æ•°æ®

åˆ›å»ºæ•°æ®ä¸‹è½½è„šæœ¬ `download_data.py`ï¼š

```python
#!/usr/bin/env python3
"""
æ•°æ®ä¸‹è½½è„šæœ¬

ä¸‹è½½Aè‚¡ã€ETFã€æŒ‡æ•°çš„å†å²æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨ã€‚
"""

import logging
from datetime import datetime, timedelta
from quantcapital.config import ConfigManager
from quantcapital.data import DataUpdater
from quantcapital.engine import EventEngine

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def main():
    """ä¸»å‡½æ•°"""
    # åŠ è½½é…ç½®
    config = ConfigManager()
    config.load_config('config/backtest.json')
    
    # åˆ›å»ºäº‹ä»¶å¼•æ“
    event_engine = EventEngine()
    event_engine.start()
    
    try:
        # åˆ›å»ºæ•°æ®æ›´æ–°å™¨
        updater = DataUpdater(config.config, event_engine)
        
        # è®¾ç½®æ•°æ®æ›´æ–°æ—¥æœŸèŒƒå›´
        end_date = datetime.now()
        start_date = end_date - timedelta(days=365)  # ä¸‹è½½ä¸€å¹´æ•°æ®
        
        logger.info(f"å¼€å§‹ä¸‹è½½æ•°æ®: {start_date.date()} - {end_date.date()}")
        
        # æ‰‹åŠ¨è§¦å‘æ•°æ®æ›´æ–°
        updater.update_data()
        
        logger.info("æ•°æ®ä¸‹è½½å®Œæˆï¼")
        
    except Exception as e:
        logger.error(f"æ•°æ®ä¸‹è½½å¤±è´¥: {e}")
    finally:
        event_engine.stop()

if __name__ == "__main__":
    main()
```

è¿è¡Œæ•°æ®ä¸‹è½½ï¼š

```bash
python download_data.py
```

### 2. æ•°æ®å­˜å‚¨ç»“æ„

ä¸‹è½½å®Œæˆåï¼Œæ•°æ®å­˜å‚¨ç»“æ„å¦‚ä¸‹ï¼š

```
data/
â”œâ”€â”€ kline/                          # Kçº¿æ•°æ®ï¼ˆParquetæ ¼å¼ï¼‰
â”‚   â”œâ”€â”€ frequency=daily/
â”‚   â”‚   â”œâ”€â”€ year=2023/
â”‚   â”‚   â”‚   â””â”€â”€ data.parquet        # æ—¥çº¿æ•°æ®
â”‚   â”‚   â””â”€â”€ year=2024/
â”‚   â”‚       â””â”€â”€ data.parquet
â”‚   â”œâ”€â”€ frequency=hourly/           # å°æ—¶çº¿æ•°æ®
â”‚   â””â”€â”€ frequency=weekly/           # å‘¨çº¿æ•°æ®
â”œâ”€â”€ business.db                     # ä¸šåŠ¡æ•°æ®ï¼ˆSQLiteï¼‰
â””â”€â”€ temp/                          # ä¸´æ—¶æ–‡ä»¶
    â””â”€â”€ *.duckdb                   # å›æµ‹æ—¶çš„å†…å­˜æ•°æ®åº“
```

### 3. æŸ¥çœ‹å·²ä¸‹è½½çš„æ•°æ®

åˆ›å»ºæ•°æ®æŸ¥çœ‹è„šæœ¬ `check_data.py`ï¼š

```python
#!/usr/bin/env python3
"""
æ•°æ®æŸ¥çœ‹è„šæœ¬

æ£€æŸ¥å·²ä¸‹è½½çš„æ•°æ®æƒ…å†µã€‚
"""

import pandas as pd
from quantcapital.config import ConfigManager
from quantcapital.data import BacktestDataHandler

def main():
    config = ConfigManager()
    config.load_config('config/backtest.json')
    
    # åˆ›å»ºæ•°æ®å¤„ç†å™¨
    data_handler = BacktestDataHandler(
        data_root=config.get('data_root'),
        business_db_path=config.get('business_db_path')
    )
    
    # æŸ¥çœ‹è‚¡ç¥¨æ± 
    universe = data_handler.business_storage.load_universe("default")
    print(f"è‚¡ç¥¨æ± åŒ…å« {len(universe)} æ”¯è‚¡ç¥¨:")
    print(universe[:10])  # æ˜¾ç¤ºå‰10æ”¯
    
    # æŸ¥çœ‹æ•°æ®ç»Ÿè®¡
    if universe:
        sample_symbol = universe[0]
        bars = data_handler.get_latest_bars([sample_symbol], "DAILY", 10)
        
        if sample_symbol in bars and bars[sample_symbol]:
            print(f"\n{sample_symbol} æœ€æ–°10ä¸ªäº¤æ˜“æ—¥æ•°æ®:")
            for bar in bars[sample_symbol][-5:]:  # æ˜¾ç¤ºæœ€è¿‘5ä¸ª
                print(f"  {bar.datetime.date()}: å¼€={bar.open:.2f}, "
                     f"é«˜={bar.high:.2f}, ä½={bar.low:.2f}, æ”¶={bar.close:.2f}")

if __name__ == "__main__":
    main()
```

è¿è¡Œæ•°æ®æ£€æŸ¥ï¼š

```bash
python check_data.py
```

## ğŸ“ˆ ç¼–å†™äº¤æ˜“ç­–ç•¥

### 1. åˆ›å»ºè‡ªå®šä¹‰ç­–ç•¥

åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªç­–ç•¥ `my_strategy.py`ï¼š

```python
from datetime import datetime
from typing import List, Set
from quantcapital.strategy import BaseStrategy
from quantcapital.entities import Signal, SignalDirection, Bar, StrategyType

class MyMATrendStrategy(BaseStrategy):
    """æˆ‘çš„å‡çº¿è¶‹åŠ¿ç­–ç•¥"""
    
    def __init__(self, strategy_instance, event_engine, data_handler):
        super().__init__(strategy_instance, event_engine)
        self.data_handler = data_handler
        
        # ç­–ç•¥å‚æ•°
        self.ma_window = self.config.get('ma_window', 20)      # å‡çº¿å‘¨æœŸ
        self.volume_threshold = self.config.get('volume_threshold', 1.2)  # æˆäº¤é‡é˜ˆå€¼
        self.universe = set(self.config.get('universe', []))
        
    def get_watch_symbols(self) -> Set[str]:
        """è·å–å…³æ³¨æ ‡çš„"""
        if self.strategy_type == StrategyType.ENTRY:
            # å¼€å•ç­–ç•¥ï¼šå…³æ³¨è‚¡ç¥¨æ± ä¸­æœªæŒæœ‰çš„æ ‡çš„
            strategy_positions = self.get_strategy_positions()
            return self.universe - strategy_positions
        elif self.strategy_type == StrategyType.EXIT:
            # æ­¢æŸç­–ç•¥ï¼šå…³æ³¨æœ¬ç­–ç•¥çš„æŒä»“
            return self.get_strategy_positions()
        return set()
    
    def generate_signals(self, market_event) -> List[Signal]:
        """ç”Ÿæˆäº¤æ˜“ä¿¡å·"""
        signals = []
        symbol = market_event.symbol
        current_bar = market_event.bar_data
        
        try:
            if self.strategy_type == StrategyType.ENTRY:
                signal = self._check_entry_signal(symbol, current_bar)
                if signal:
                    signals.append(signal)
            elif self.strategy_type == StrategyType.EXIT:
                signal = self._check_exit_signal(symbol, current_bar)
                if signal:
                    signals.append(signal)
        except Exception as e:
            self.logger.debug(f"ç”Ÿæˆä¿¡å·å¤±è´¥ {symbol}: {e}")
        
        return signals
    
    def _check_entry_signal(self, symbol: str, current_bar: Bar) -> Signal:
        """æ£€æŸ¥å¼€å•ä¿¡å·"""
        # è·å–å†å²æ•°æ®
        historical_bars = self._get_historical_data(symbol, self.ma_window + 5)
        
        if len(historical_bars) < self.ma_window:
            return None
        
        # è®¡ç®—å‡çº¿
        ma_current = self._calculate_ma(historical_bars, self.ma_window)
        ma_prev = self._calculate_ma(historical_bars[:-1], self.ma_window)
        
        if ma_current is None or ma_prev is None:
            return None
        
        # ç­–ç•¥é€»è¾‘ï¼šä»·æ ¼ä¸Šç©¿å‡çº¿ + æˆäº¤é‡æ”¾å¤§
        price_breakout = (current_bar.close > ma_current and 
                         historical_bars[-2].close <= ma_prev)
        
        # è®¡ç®—æˆäº¤é‡æ¯”ï¼ˆå½“å‰æˆäº¤é‡ vs å¹³å‡æˆäº¤é‡ï¼‰
        avg_volume = sum(bar.volume for bar in historical_bars[-10:]) / 10
        volume_surge = current_bar.volume > avg_volume * self.volume_threshold
        
        if price_breakout and volume_surge:
            return Signal(
                strategy_id=self.strategy_id,
                symbol=symbol,
                direction=SignalDirection.BUY,
                strength=0.8,
                timestamp=current_bar.datetime,
                price=current_bar.close,
                reason=f"ä»·æ ¼ä¸Šç©¿å‡çº¿+æˆäº¤é‡æ”¾å¤§: MA={ma_current:.2f}, é‡æ¯”={current_bar.volume/avg_volume:.2f}"
            )
        
        return None
    
    def _check_exit_signal(self, symbol: str, current_bar: Bar) -> Signal:
        """æ£€æŸ¥æ­¢æŸä¿¡å·"""
        if not self.portfolio_manager or not self.portfolio_manager.account:
            return None
        
        position = self.portfolio_manager.account.get_position(symbol)
        if not position or position.is_empty:
            return None
        
        # æ­¢æŸé€»è¾‘ï¼šè·Œç ´å‡çº¿
        historical_bars = self._get_historical_data(symbol, self.ma_window + 5)
        if len(historical_bars) < self.ma_window:
            return None
        
        ma_current = self._calculate_ma(historical_bars, self.ma_window)
        if ma_current is None:
            return None
        
        if current_bar.close < ma_current:
            return Signal(
                strategy_id=self.strategy_id,
                symbol=symbol,
                direction=SignalDirection.SELL,
                strength=0.9,
                timestamp=current_bar.datetime,
                price=current_bar.close,
                reason=f"è·Œç ´å‡çº¿æ­¢æŸ: å½“å‰ä»·={current_bar.close:.2f}, MA={ma_current:.2f}"
            )
        
        return None
    
    def _get_historical_data(self, symbol: str, count: int) -> List[Bar]:
        """è·å–å†å²æ•°æ®"""
        try:
            from quantcapital.entities import Frequency
            bars_dict = self.data_handler.get_latest_bars([symbol], Frequency.DAILY, count)
            return bars_dict.get(symbol, [])
        except Exception as e:
            return []
    
    def _calculate_ma(self, bars: List[Bar], window: int) -> float:
        """è®¡ç®—ç§»åŠ¨å¹³å‡çº¿"""
        if len(bars) < window:
            return None
        
        prices = [bar.close for bar in bars[-window:]]
        return sum(prices) / len(prices)
```

### 2. ç­–ç•¥é…ç½®

åˆ›å»ºç­–ç•¥é…ç½®æ–‡ä»¶ `strategies/my_trend_config.json`ï¼š

```json
{
  "strategy_id": "my_ma_trend_entry",
  "name": "æˆ‘çš„å‡çº¿è¶‹åŠ¿å¼€å•ç­–ç•¥",
  "strategy_type": "entry",
  "enabled": true,
  "config": {
    "ma_window": 20,
    "volume_threshold": 1.5,
    "universe": [
      "000001.SZ", "000002.SZ", "000858.SZ", "000725.SZ",
      "600000.SH", "600036.SH", "600519.SH", "600276.SH"
    ]
  }
}
```

## ğŸ”¬ è¿è¡Œå›æµ‹

### 1. åˆ›å»ºå›æµ‹è„šæœ¬

åˆ›å»ºå®Œæ•´å›æµ‹è„šæœ¬ `run_backtest.py`ï¼š

```python
#!/usr/bin/env python3
"""
å›æµ‹è¿è¡Œè„šæœ¬

ä½¿ç”¨è‡ªå®šä¹‰ç­–ç•¥è¿›è¡Œå†å²å›æµ‹ã€‚
"""

import json
import logging
from datetime import datetime, timedelta
from quantcapital.config import ConfigManager
from quantcapital.backtest import BacktestEngine
from quantcapital.entities import StrategyInstance, StrategyType
from my_strategy import MyMATrendStrategy

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def load_strategy_config(config_file: str) -> StrategyInstance:
    """åŠ è½½ç­–ç•¥é…ç½®"""
    with open(config_file, 'r', encoding='utf-8') as f:
        config_data = json.load(f)
    
    return StrategyInstance(
        strategy_id=config_data['strategy_id'],
        name=config_data['name'],
        strategy_type=StrategyType(config_data['strategy_type']),
        enabled=config_data['enabled'],
        config=config_data['config']
    )

def main():
    """ä¸»å‡½æ•°"""
    # åŠ è½½é…ç½®
    config = ConfigManager()
    config.load_config('config/backtest.json')
    
    # åˆ›å»ºå›æµ‹å¼•æ“
    backtest_engine = BacktestEngine(config)
    
    # è®¾ç½®å›æµ‹å‚æ•°
    end_date = datetime.now()
    start_date = end_date - timedelta(days=90)  # å›æµ‹3ä¸ªæœˆ
    
    # åŠ è½½ç­–ç•¥é…ç½®
    strategy_config = load_strategy_config('strategies/my_trend_config.json')
    universe = strategy_config.config['universe']
    
    logger.info(f"å›æµ‹è®¾ç½®:")
    logger.info(f"  æ—¶é—´èŒƒå›´: {start_date.date()} - {end_date.date()}")
    logger.info(f"  è‚¡ç¥¨æ± : {len(universe)} æ”¯è‚¡ç¥¨")
    logger.info(f"  åˆå§‹èµ„é‡‘: {config.get('initial_capital'):,.0f} å…ƒ")
    
    # åˆ›å»ºç­–ç•¥å®ä¾‹
    entry_strategy = MyMATrendStrategy(
        strategy_config, 
        backtest_engine.event_engine,
        None  # æ•°æ®å¤„ç†å™¨å°†åœ¨setupæ—¶è®¾ç½®
    )
    
    # åˆ›å»ºå¯¹åº”çš„æ­¢æŸç­–ç•¥
    exit_config = StrategyInstance(
        strategy_id="my_ma_trend_exit",
        name="æˆ‘çš„å‡çº¿è¶‹åŠ¿æ­¢æŸç­–ç•¥",
        strategy_type=StrategyType.EXIT,
        enabled=True,
        config=strategy_config.config
    )
    
    exit_strategy = MyMATrendStrategy(
        exit_config,
        backtest_engine.event_engine,
        None
    )
    
    # è®¾ç½®å›æµ‹å‚æ•°
    backtest_engine.setup(
        start_date=start_date,
        end_date=end_date,
        universe=universe,
        strategies=[entry_strategy, exit_strategy]
    )
    
    # ä¸ºç­–ç•¥è®¾ç½®æ•°æ®å¤„ç†å™¨
    entry_strategy.data_handler = backtest_engine.data_handler
    exit_strategy.data_handler = backtest_engine.data_handler
    
    try:
        # å‡†å¤‡æ•°æ®
        logger.info("å‡†å¤‡å›æµ‹æ•°æ®...")
        if not backtest_engine.prepare_data():
            logger.error("æ•°æ®å‡†å¤‡å¤±è´¥")
            return
        
        # è¿è¡Œå›æµ‹
        logger.info("å¼€å§‹è¿è¡Œå›æµ‹...")
        if backtest_engine.run():
            # æ‰“å°ç»“æœ
            backtest_engine.print_results()
            
            # ä¿å­˜è¯¦ç»†ç»“æœ
            results = backtest_engine.get_results()
            with open('backtest_results.json', 'w', encoding='utf-8') as f:
                # è½¬æ¢datetimeä¸ºå­—ç¬¦ä¸²
                results_json = {}
                for key, value in results.items():
                    if isinstance(value, datetime):
                        results_json[key] = value.isoformat()
                    else:
                        results_json[key] = value
                
                json.dump(results_json, f, indent=2, ensure_ascii=False)
            
            logger.info("å›æµ‹ç»“æœå·²ä¿å­˜åˆ° backtest_results.json")
        else:
            logger.error("å›æµ‹è¿è¡Œå¤±è´¥")
    
    except KeyboardInterrupt:
        logger.info("ç”¨æˆ·ä¸­æ–­å›æµ‹")
    except Exception as e:
        logger.error(f"å›æµ‹æ‰§è¡Œå¼‚å¸¸: {e}", exc_info=True)

if __name__ == "__main__":
    main()
```

### 2. è¿è¡Œå›æµ‹

```bash
# ç¡®ä¿æ•°æ®å·²ä¸‹è½½
python download_data.py

# è¿è¡Œå›æµ‹
python run_backtest.py
```

### 3. æŸ¥çœ‹å›æµ‹ç»“æœ

å›æµ‹å®Œæˆåï¼Œä½ å°†çœ‹åˆ°ç±»ä¼¼ä»¥ä¸‹çš„è¾“å‡ºï¼š

```
============================================================
å›æµ‹ç»“æœæ‘˜è¦
============================================================
å›æµ‹æœŸé—´: 2024-01-01 - 2024-03-31
åˆå§‹èµ„é‡‘: 1,000,000.00 å…ƒ
æœ€ç»ˆä»·å€¼: 1,035,240.00 å…ƒ
æ€»æ”¶ç›Šç‡: 3.52%
æ€»äº¤æ˜“æ¬¡æ•°: 15
èƒœç‡: 66.67%
æ€»æ‰‹ç»­è´¹: 89.50 å…ƒ
å·²å®ç°ç›ˆäº: 35,329.50 å…ƒ

ç­–ç•¥ç»Ÿè®¡:
  æ€»ç­–ç•¥æ•°: 2
  æ´»è·ƒç­–ç•¥æ•°: 2

æŒä»“ç»Ÿè®¡:
  æŒä»“æ•°é‡: 3
  æŒä»“ä»·å€¼: 298,740.00 å…ƒ
  æ æ†ç‡: 0.30
============================================================
```

## ğŸ”§ é«˜çº§åŠŸèƒ½

### 1. ç­–ç•¥å‚æ•°ä¼˜åŒ–

åˆ›å»ºå‚æ•°ä¼˜åŒ–è„šæœ¬ `optimize_strategy.py`ï¼š

```python
#!/usr/bin/env python3
"""
ç­–ç•¥å‚æ•°ä¼˜åŒ–

é€šè¿‡ç½‘æ ¼æœç´¢æ‰¾åˆ°æœ€ä¼˜å‚æ•°ç»„åˆã€‚
"""

import itertools
from run_backtest import main as run_single_backtest

def optimize_parameters():
    """å‚æ•°ä¼˜åŒ–"""
    # å®šä¹‰å‚æ•°èŒƒå›´
    ma_windows = [10, 15, 20, 25, 30]
    volume_thresholds = [1.2, 1.5, 1.8, 2.0]
    
    best_return = -float('inf')
    best_params = None
    results = []
    
    # ç½‘æ ¼æœç´¢
    for ma_window, volume_threshold in itertools.product(ma_windows, volume_thresholds):
        print(f"æµ‹è¯•å‚æ•°: MAçª—å£={ma_window}, æˆäº¤é‡é˜ˆå€¼={volume_threshold}")
        
        # ä¿®æ”¹é…ç½®æ–‡ä»¶
        # ... æ›´æ–°ç­–ç•¥é…ç½® ...
        
        # è¿è¡Œå›æµ‹
        result = run_single_backtest()
        
        if result and result['total_return'] > best_return:
            best_return = result['total_return']
            best_params = (ma_window, volume_threshold)
        
        results.append({
            'ma_window': ma_window,
            'volume_threshold': volume_threshold,
            'return': result['total_return'] if result else None
        })
    
    print(f"æœ€ä¼˜å‚æ•°: MAçª—å£={best_params[0]}, æˆäº¤é‡é˜ˆå€¼={best_params[1]}")
    print(f"æœ€ä¼˜æ”¶ç›Šç‡: {best_return:.2%}")

if __name__ == "__main__":
    optimize_parameters()
```

### 2. å®ç›˜äº¤æ˜“å‡†å¤‡

åˆ›å»ºå®ç›˜é…ç½® `config/live_trading.json`ï¼š

```json
{
  "env": "live_trading",
  "data_root": "./data",
  "business_db_path": "./data/business.db",
  "initial_capital": 100000.0,
  "execution": {
    "slippage": 0.002,
    "commission_rate": 0.0003,
    "delay_seconds": 2,
    "miniapi_config": {
      "host": "localhost",
      "port": 8888,
      "username": "your_username",
      "password": "your_password"
    }
  },
  "portfolio": {
    "max_position_pct": 0.03,
    "max_total_position_pct": 0.85,
    "min_order_amount": 5000
  },
  "risk": {
    "daily_loss_limit": 0.02,
    "max_drawdown": 0.05
  }
}
```

### 3. ç›‘æ§å’ŒæŠ¥è­¦

åˆ›å»ºç›‘æ§è„šæœ¬ `monitor.py`ï¼š

```python
#!/usr/bin/env python3
"""
äº¤æ˜“ç›‘æ§è„šæœ¬

ç›‘æ§å®ç›˜äº¤æ˜“çŠ¶æ€å’Œé£é™©æŒ‡æ ‡ã€‚
"""

import time
import smtplib
from email.mime.text import MIMEText
from quantcapital.config import ConfigManager
from quantcapital.portfolio import PortfolioRiskManager

def send_alert(subject: str, message: str):
    """å‘é€é‚®ä»¶å‘Šè­¦"""
    # é…ç½®é‚®ä»¶æœåŠ¡å™¨
    # ... å‘é€é‚®ä»¶é€»è¾‘ ...
    pass

def monitor_trading():
    """ç›‘æ§äº¤æ˜“çŠ¶æ€"""
    while True:
        try:
            # æ£€æŸ¥è´¦æˆ·çŠ¶æ€
            # ... ç›‘æ§é€»è¾‘ ...
            
            # æ£€æŸ¥é£é™©æŒ‡æ ‡
            # ... é£é™©æ£€æŸ¥ ...
            
            time.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
            
        except Exception as e:
            send_alert("äº¤æ˜“ç›‘æ§å¼‚å¸¸", f"ç›‘æ§ç¨‹åºå¼‚å¸¸: {e}")
            time.sleep(300)  # å¼‚å¸¸æ—¶ç­‰å¾…5åˆ†é’Ÿ

if __name__ == "__main__":
    monitor_trading()
```

## ğŸ“š è¿›é˜¶å­¦ä¹ 

### 1. äº†è§£æ¡†æ¶æ¶æ„

- **äº‹ä»¶é©±åŠ¨**: æ‰€æœ‰ç»„ä»¶é€šè¿‡äº‹ä»¶é€šä¿¡ï¼Œè§£è€¦åˆè®¾è®¡
- **åˆ†å±‚å­˜å‚¨**: Parquet(å½’æ¡£) + DuckDB(æŸ¥è¯¢) + SQLite(ä¸šåŠ¡)
- **ç­–ç•¥åˆ†ç¦»**: å¼€å•ã€æ­¢æŸã€é£æ§ç­–ç•¥ç‹¬ç«‹è¿è¡Œ
- **å›æµ‹ä¸€è‡´æ€§**: ç›¸åŒä»£ç å¯ç”¨äºå›æµ‹å’Œå®ç›˜

### 2. æ‰©å±•æ¡†æ¶åŠŸèƒ½

```python
# è‡ªå®šä¹‰æŠ€æœ¯æŒ‡æ ‡
from quantcapital.data.indicators import TechnicalIndicators

class MyIndicators(TechnicalIndicators):
    def calculate_custom_indicator(self, bars):
        # å®ç°è‡ªå®šä¹‰æŒ‡æ ‡
        pass

# è‡ªå®šä¹‰æ•°æ®æº
from quantcapital.data.data_source import DataSource

class MyDataSource(DataSource):
    def get_kline_data(self, symbols, frequency, start_date, end_date):
        # å®ç°è‡ªå®šä¹‰æ•°æ®è·å–
        pass
```

### 3. æ€§èƒ½ä¼˜åŒ–

- **æ•°æ®é¢„åŠ è½½**: å›æµ‹å‰å°†æ•°æ®åŠ è½½åˆ°å†…å­˜
- **å¹¶è¡Œè®¡ç®—**: å¤šè¿›ç¨‹å¤„ç†å¤§é‡æ ‡çš„
- **ç¼“å­˜æœºåˆ¶**: ç¼“å­˜æŠ€æœ¯æŒ‡æ ‡è®¡ç®—ç»“æœ
- **å¢é‡æ›´æ–°**: åªæ›´æ–°æœ€æ–°çš„æ•°æ®

## â“ å¸¸è§é—®é¢˜

### Q: å¦‚ä½•æ·»åŠ æ–°çš„è‚¡ç¥¨åˆ°è‚¡ç¥¨æ± ï¼Ÿ

```python
from quantcapital.data import BacktestDataHandler

data_handler = BacktestDataHandler(data_root="./data", business_db_path="./data/business.db")
current_universe = data_handler.business_storage.load_universe("default")
new_universe = current_universe + ["600519.SH", "000858.SZ"]
data_handler.business_storage.save_universe("default", new_universe)
```

### Q: å¦‚ä½•è°ƒè¯•ç­–ç•¥ä¿¡å·ï¼Ÿ

```python
# åœ¨ç­–ç•¥ä¸­æ·»åŠ è¯¦ç»†æ—¥å¿—
import logging
logger = logging.getLogger(__name__)

def generate_signals(self, market_event):
    logger.debug(f"å¤„ç† {market_event.symbol} è¡Œæƒ…: æ”¶ç›˜ä»·={market_event.bar_data.close:.2f}")
    # ... ç­–ç•¥é€»è¾‘ ...
```

### Q: å¦‚ä½•å¤„ç†åœç‰Œè‚¡ç¥¨ï¼Ÿ

æ¡†æ¶ä¼šè‡ªåŠ¨è·³è¿‡æ— æ•°æ®çš„äº¤æ˜“æ—¥ï¼Œåœç‰Œè‚¡ç¥¨ä¸ä¼šè§¦å‘äº¤æ˜“ä¿¡å·ã€‚

### Q: å¦‚ä½•è®¾ç½®ä¸åŒçš„æ‰‹ç»­è´¹ç‡ï¼Ÿ

åœ¨é…ç½®æ–‡ä»¶ä¸­ä¿®æ”¹ `execution.commission_rate`ï¼Œæ”¯æŒä¹°å–ä¸åŒè´¹ç‡ã€‚

## ğŸ“ è·å–æ”¯æŒ

- **æ–‡æ¡£**: æŸ¥çœ‹é¡¹ç›® README å’Œä»£ç æ³¨é‡Š
- **æµ‹è¯•**: è¿è¡Œ `pytest tests/` éªŒè¯åŠŸèƒ½
- **ç¤¾åŒº**: æäº¤ Issue æˆ– Pull Request

---

**ç¥æ‚¨ä½¿ç”¨æ„‰å¿«ï¼å¼€å§‹æ‚¨çš„é‡åŒ–äº¤æ˜“ä¹‹æ—…å§ï¼** ğŸ‰