# QuantCapital Java交易引擎 - 用户手册

## 📋 概述

QuantCapital Java交易引擎是高性能的量化交易系统核心组件，采用混合架构设计：
- **Python**：负责数据获取与存储（AKShare、技术指标计算、Parquet文件、DuckDB、SQLite）
- **Java**：负责事件驱动引擎及整个回测/实盘交易流程

### 🎯 核心特性

- ⚡ **高性能**：基于Java 21虚拟线程，ZGC垃圾收集器，支持万级TPS事件处理
- 🔄 **事件驱动**：异步事件处理架构，故障隔离，低延迟响应
- 📊 **数据兼容**：完美读取Python生成的Parquet、DuckDB、SQLite数据
- 🧠 **智能策略**：支持开单策略、止盈止损策略、通用强制止损策略
- 🛡️ **风控完善**：多层次风控检查，实时仓位管理，风险监控
- 🔧 **配置灵活**：支持回测/实盘环境切换，参数热更新

## 🚀 快速开始

### 1. 环境要求

- **Java 21+** （必须支持虚拟线程）
- **Maven 3.8+**
- **内存**: 建议8GB以上
- **存储**: 10GB以上（用于数据存储）

### 2. 安装和启动

```bash
# 1. 克隆项目
git clone <repository-url>
cd quant-trading-java

# 2. 编译项目
mvn clean compile

# 3. 运行测试（验证环境）
mvn test

# 4. 启动回测模式
mvn spring-boot:run -Dspring.profiles.active=backtest

# 5. 启动实盘模式
mvn spring-boot:run -Dspring.profiles.active=live
```

### 3. 配置说明

主要配置文件：`src/main/resources/application.yml`

```yaml
quantcapital:
  mode: backtest  # 运行模式: backtest, live
  
  # 数据配置 - 读取Python生成的数据
  data:
    root-path: "./data"  # Python数据存储根目录
    parquet-path: "./data/kline"  # K线数据路径
    sqlite-path: "./data/business.db"  # 业务数据库
  
  # 账户配置
  account:
    initial-capital: 1000000.0  # 初始资金（元）
  
  # 组合风控配置
  portfolio:
    max-position-percent: 5.0     # 单标的最大仓位(%)
    max-total-position-percent: 95.0  # 总仓位上限(%)
    min-order-amount: 1000.0      # 最小下单金额(元)
```

## 📊 数据接入

### Python数据准备

确保Python端已生成以下数据：

```bash
data/
├── kline/                    # K线数据（Parquet格式）
│   ├── frequency=daily/
│   ├── frequency=hourly/
│   └── ...
├── business.db              # SQLite业务数据库
└── indicators/              # 技术指标数据
```

### 数据验证

启动后访问：`http://localhost:8080/api/actuator/health`

```json
{
  "status": "UP",
  "components": {
    "dataHealth": {
      "status": "UP",
      "details": {
        "symbols": 1000,
        "dateRange": "2023-01-01 to 2023-12-31",
        "lastUpdate": "2023-12-31T15:00:00"
      }
    }
  }
}
```

## 🔧 核心功能

### 1. 事件驱动引擎

系统基于事件驱动架构，支持以下事件类型：

- **MarketEvent**: 市场数据更新事件
- **SignalEvent**: 策略信号事件
- **OrderEvent**: 订单事件
- **FillEvent**: 成交事件
- **TimerEvent**: 定时器事件

### 2. 策略框架

支持三种策略类型：

#### 开单策略（Entry Strategy）
```java
@Component
public class MyEntryStrategy implements BaseStrategy {
    @Override
    public List<Signal> onMarketEvent(MarketEvent event) {
        // 分析市场数据，产生买入信号
        Bar bar = event.getBar();
        if (买入条件满足) {
            Signal signal = new Signal(
                getStrategyId(), 
                bar.getSymbol(),
                SignalDirection.BUY,
                0.8,  // 信号强度
                LocalDateTime.now(),
                bar.getClose(),
                "技术指标金叉"
            );
            return List.of(signal);
        }
        return List.of();
    }
}
```

#### 止盈止损策略（Exit Strategy）
```java
@Component
public class MyExitStrategy implements BaseStrategy {
    @Override
    public List<Signal> onMarketEvent(MarketEvent event) {
        // 检查已有持仓，产生卖出信号
        // 实现止盈、止损逻辑
        return signals;
    }
}
```

### 3. 风控系统

自动风控检查包括：

- **仓位控制**: 单标的仓位≤5%，总仓位≤95%
- **资金管理**: 可用资金检查，冻结资金管理
- **风险监控**: 日内亏损≤2%，最大回撤≤10%
- **合规检查**: ST股票限制，新股检查

### 4. 执行系统

支持两种执行模式：

#### 回测执行
- 模拟市场成交
- 滑点和手续费模拟
- 延迟模拟

#### 实盘执行（预留MiniQMT接口）
- 真实订单执行
- 实时风控检查
- 异常处理和重试

## 📈 使用示例

### 简单的均线交叉策略

```java
@Component
public class MACrossStrategy implements BaseStrategy {
    
    private final String strategyId = "ma_cross_strategy";
    
    @Override
    public List<Signal> onMarketEvent(MarketEvent event) {
        Bar bar = event.getBar();
        
        // 检查技术指标是否可用
        if (bar.getMa5() == null || bar.getMa20() == null) {
            return List.of();
        }
        
        List<Signal> signals = new ArrayList<>();
        
        // 金叉买入信号
        if (bar.getMa5() > bar.getMa20() && 
            isGoldenCross(bar.getSymbol())) {
            
            Signal buySignal = new Signal(
                strategyId,
                bar.getSymbol(),
                SignalDirection.BUY,
                0.7,
                LocalDateTime.now(),
                bar.getClose(),
                "MA5上穿MA20金叉买入"
            );
            signals.add(buySignal);
        }
        
        return signals;
    }
    
    private boolean isGoldenCross(String symbol) {
        // 检查前一期是否MA5 < MA20（确认是金叉）
        // 实现逻辑...
        return true;
    }
    
    @Override
    public String getStrategyId() { return strategyId; }
    @Override
    public String getName() { return "均线交叉策略"; }
    @Override
    public StrategyType getStrategyType() { return StrategyType.ENTRY; }
    // ... 其他必须实现的方法
}
```

### 运行回测

```java
@RestController
public class BacktestController {
    
    @Autowired
    private EventEngine eventEngine;
    
    @PostMapping("/api/backtest/start")
    public ResponseEntity<String> startBacktest(@RequestBody BacktestRequest request) {
        // 配置回测参数
        BacktestConfig config = BacktestConfig.builder()
            .startDate(request.getStartDate())
            .endDate(request.getEndDate())
            .universe(request.getSymbols())
            .initialCapital(request.getCapital())
            .build();
        
        // 启动回测
        BacktestEngine backtestEngine = new BacktestEngine(config);
        backtestEngine.start();
        
        return ResponseEntity.ok("回测已启动");
    }
}
```

## 🔍 监控和调试

### 1. 系统监控

访问监控端点：
- 健康检查: `GET /api/actuator/health`
- 性能指标: `GET /api/actuator/metrics`
- 事件引擎统计: `GET /api/engine/stats`

```json
{
  "running": true,
  "queueSize": 10,
  "totalEvents": 50000,
  "processedEvents": 49995,
  "failedEvents": 3,
  "droppedEvents": 2,
  "eventsPerSecond": 1250.5
}
```

### 2. 日志配置

日志文件位置：`logs/quant-trading.log`

关键日志模块：
- `com.quantcapital.engine`: 事件引擎日志
- `com.quantcapital.strategy`: 策略执行日志
- `com.quantcapital.portfolio`: 风控日志
- `com.quantcapital.execution`: 订单执行日志

### 3. 性能调优

JVM启动参数建议：
```bash
java -XX:+UseZGC \
     -XX:+UnlockExperimentalVMOptions \
     -Xmx8g \
     -XX:+FlightRecorder \
     --enable-preview \
     -jar trading-engine.jar
```

## ⚠️ 注意事项

### 数据一致性
- 确保Python数据更新及时
- 定期检查数据完整性
- 监控数据延迟

### 风险控制
- 严格遵守仓位限制
- 定期检查止损设置
- 监控系统异常

### 性能监控
- 关注事件处理延迟
- 监控内存使用情况
- 及时处理队列堆积

## 🆘 故障排除

### 常见问题

1. **启动失败**
   ```
   检查Java版本是否21+
   检查数据目录是否存在
   确认配置文件正确
   ```

2. **数据加载异常**
   ```
   验证Python数据是否存在
   检查文件权限
   确认数据格式正确
   ```

3. **事件处理延迟**
   ```
   检查队列大小
   增加工作线程数
   优化策略逻辑
   ```

4. **内存不足**
   ```
   增加JVM堆内存
   启用ZGC垃圾收集器
   减少数据预加载量
   ```

### 技术支持

- 查看项目Wiki文档
- 提交GitHub Issue
- 联系开发团队

---

> **免责声明**: 本系统仅用于学习和研究目的，实盘交易有风险，投资需谨慎。使用者应充分评估风险，后果自负。